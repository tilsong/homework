# 0218



## (인프런) [그림으로이해하는] 동기(sync) 비동기(async)의 개념에 대한 가장 직관적인 이해

> 출처: https://www.inflearn.com/course/sync-async-%EA%B0%9C%EB%85%90-%EC%9D%B4%ED%95%B4


### 1. 비동기 - 동기

- 비동기 → 다른 쓰레드에 일을 시키고, 그 자신은 더 이상 관여하지 않는다.안 기다린다. (동시성)

  ​		    →메인쓰레드(일 시킨 쓰레드)가 다른 일 처리를 시작할 수 있다. (다른 작업 생성 가능)

- 동기 → 작업을 다른 쓰레드에 시작시키고, 그 작업이 끝날때까지 기다린다.

  ​			(기다린 후 새 작업 생성)

- 비동기라는 개념이 필요한 이유? → 대부분은 서버와의 통신(네트워크 작업) 때문



### 2. 직렬 - 동시성

- 직렬(Serial) - 다른 **하나**의 쓰레드로만 작업을 보냄

  → 순서가 중요한 작업을 처리할 때 사용

- 동시성, 병렬(Concurrent) - 다른 **여러 개**의 쓰레드로 분산 처리

  → 각자 독립적이지만 유사한 여러개의 작업을 처리할 때 사용

- 동시처리가 좋아보이는데 직렬처리 필요한 이유? -> 작업에 순서가 필요할 수 있기 때문이다.



### 결론

- 결국 동기-비동기 개념은  스레드에서 다른 스레드로 작업을 보내는데 관련된 개념이고, 직렬-동시성 개념은 보내지는 스레드가 어디로 가는가에 관련되어 있는 개념이다.

- 메인 스레드에서만 일을 시키면? 

  → 메인 스레드가 계속 버벅이게 된다. 특히 유저와 관련된 화면을 관리하기 때문에, 작업을 시킬수록 좋지 않다. 네트워크 관련 내용은 다른 스레드에 그 내용을 맡겨야 한다.

   이러한 이유들 때문에 성능, 최적화와 관련된 내용을 다룰 때 동기 비동기 내용이 등장하게 된다.

-------------------------------------------------------------------------------------------------------------------

## Wrapper 클래스와 Auto Boxing/UnBoxing

> 출처 : 유투브 뉴렉쳐 강의 https://www.youtube.com/channel/UC5-ixpj8DioZqmrasj6Ihpw

- 원시 타입을 객체에 담기게 하려면? → boxing을 해서 참조시키는 작업을 해야함.

- 그렇지만 현재는 오토 박싱이 되어 Object obj = 3; 과 같은 코드로도 위의 과정 없이 작동될 수 있다. 반대의 과정을 unboxing이라고 한다.

- 이러한Boxing에 사용되는 클래스가 바로 Wrapper 클래스이다. 원시 타입은 NUMBER 을 통해 래핑이 가능하다. 

- 그래서 값 형식 int x =3; / 참조 형식 Integer x =3; 두 모양으로 객체화의 형태가 나타나게 된다. 그러나 이 둘은 다른 것이며, 두번째 방식은 박싱, 언박싱으로 인해 과정이 많아진다.

  ​	=> Integer x =3; → Integer x = new Integer(3);

     => add(x,4); → add(3,4);   —> 이처럼 매개변수를 대입할 때도 래핑이 일어난다.

- 모든 데이터를 단일하게 일괄 관리하기 위한 방법이 필요해졌다. 따라서 Object에 모든 데이터를 담을 수 있도록 하여 사용하게 되었다.
- 그러나 이 방식은 담은 후 다시 이를 사용하려 할 때 원래 어떤 값을 가졌는지 확신할 수 없는 경우가 있을 수 있고, 또한 값을 다시 형변환해주어야만 한다는 단점을 가진다.

- 이러한 단점을 극복하기 위해, 제네릭이 등장하게 되었다. 제네릭은 Object와 같이 모든 타입을 받을 수 있으면서도, 다시 값을 사용할 때 형변환을 할 필요가 없다.